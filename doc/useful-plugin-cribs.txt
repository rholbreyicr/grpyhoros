
iteratinng over pixels

/Users/rholbrey/imaging/src/osirixplugins/CMIV_CTA_TOOLS/CMIVExport.m

    /*
     
     for(ii=0;ii<[fileList count];ii++)
     {
         NSAutoreleasePool    *pool = [[NSAutoreleasePool alloc] init];
                     long    err;
         curPix=[pixList objectAtIndex: ii];
         
         width=[curPix pwidth];
         height=[curPix pheight];
         srcf.height = height;
         srcf.width = width;
         srcf.rowBytes = width * sizeof( float);
         srcf.data = [curPix fImage];
         
         dst8.height =  height;
         dst8.width = width;
         dst8.rowBytes = width * sizeof( short);
         dst8.data = data;
         

         
         
         vImageConvert_FTo16U( &srcf, &dst8, -1024,  1, 0);    //By default, we use a 1024 rescale intercept !!
         [self setSourceFile: [[fileList objectAtIndex:ii] valueForKey:@"completePath"]];
         
     
     */


current image

32BitFloatDICOMExport/FloatDICOMExport.m

--------------------------

HipArthroplastyTemplating/Sources/ArthroplastyTemplatingStepsController.mm:24:
(DOES NOT BUILD)

.....
#import <OsiriXAPI/NSThread+N2.h>
#import <OsiriXAPI/ThreadModalForWindowController.h>
#import <OsiriXAPI/Notifications.h>

              NSThread* thread = [NSThread performBlockInBackground:^{
                    NSThread* thread = [NSThread currentThread];
                    thread.name = NSLocalizedString(@"Calculating object diameter...", nil);
                    thread.status = NSLocalizedString(@"If you didn't click inside a calibration object, you better cancel this calculation.", nil);
                    thread.supportsCancel = YES;
                    
                    NSMutableArray* contour = [NSMutableArray array];
                    BOOL r = [HipAT2D gro
                    
                    
                    ......
                    
                     }];
                     
-------------------------

KeyObjectSelection/Sources/KeyObjectSelectionFilter.mm:20


#import <OsiriXAPI/ThreadsManager.h>                     


    NSThread* thread = [NSThread currentThread];
    if ([thread.threadDictionary objectForKey:KOSIsApplyingKOsThreadKey])
        return; // the plugin is assigning this flag, don't react...
    if ([thread.threadDictionary objectForKey:KOSIsSettingKeyFlagThreadKey])
        return; // this is the consequence of a setIsKeyImage call (the SC being added to the DB), don't react
  
  
        
	[NSThread performBlockInBackground: ^{
	// findscu/movescu pacsdevarch 4444 -aet CIH-1208 -S -k 0008,0052=SERIES -k 0020,000d=2.16.840.1.113669.632.20.1211.10001556317 -k 0008,0060=KO
	NSString* tAET = [NSUserDefaults.standardUserDefaults stringForKey:KOSAETKey];
	NSString* tHost = [NSUserDefaults.standardUserDefaults stringForKey:KOSNodeHostKey];
	NSInteger tPort = [NSUserDefaults.standardUserDefaults integerForKey:KOSNodePortKey];
	
	DicomImage* image  = [d objectAtIndex:0];
	DicomSeries* series = [image series];
	DicomStudy* study = [series study];
	
	NSThread* thread = [NSThread currentThread];
	thread.name = [NSString stringWithFormat:NSLocalizedString(@"KeyObjects for %@", nil), study.name];
	[ThreadsManager.defaultManager addThreadAndStart:thread];

	thread.status = [NSString stringWithFormat:NSLocalizedString(@"Loading...", nil)];
							 
    ....
    
 //-----------------------------------
 
 HSS/Sources/HSSAuthenticationWindowController.mm:41:
 
 	if ((self = [super initWithWindowNibName:@"HSSAuthenticationWindow"])) {
		_timerLock = [[NSLock alloc] init];
        _previousMessageHeight = -7;
		//[HUG checkMasterUserAgain];
		[self _timerCallback:nil];
		_timer = [NSTimer scheduledTimerWithTimeInterval:0.25 target:self selector:@selector(_timerCallback:) userInfo:nil repeats:YES];
		[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes];
	}


/////////////////////////////////////////////////

HOROSPLUGINS

DiscPublishing/Classes/DiscPublishingToolAppDelegate.mm:427:
etc

*** this seems to have a lot of threading ***
==============================================




-(void)roiRemoved:(NSNotification*)notification {
	ROI *roi = [notification object];
	
	[_knownRois removeObject:roi];

    if (roi == _magnificationLine) {
		_magnificationLine = NULL;
		[_stepCalibration setDone:NO];
		[_steps setCurrentStep:_stepCalibration];
        NSArray* ps = [roi points];
        if (ps.count) {
            BOOL go = YES;
            MyPoint* p = [ps objectAtIndex:0];
            for (int i = 1; go && i < ps.count; ++i) {
                MyPoint* q = [ps objectAtIndex:i];
                if (p.x != q.x || p.y != q.y)
                    go = NO;
            }
            
            if (go) {
                NSThread* thread = [NSThread performBlockInBackground:^{
                    NSThread* thread = [NSThread currentThread];
                    thread.name = NSLocalizedString(@"Calculating object diameter...", nil);
                    thread.status = NSLocalizedString(@"If you didn't click inside a calibration object, you better cancel this calculation.", nil);
                    thread.supportsCancel = YES;
                    
                    NSMutableArray* contour = [NSMutableArray array];
                    BOOL r = [HipAT2D growRegionFromPoint:[HipAT2DIntegerPoint pointWith:roundf(p.x):roundf(p.y)] onDCMPix:[self.viewerController.pixList objectAtIndex:self.viewerController.imageView.curImage] outputPoints:nil outputContour:contour];
                    if (!r) return;
                    
                    NSArray* ps = [HipAT2D mostDistantPairOfPointsInArray:contour];
                    
                    if (ps)
                        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
                            // create the ROI
                            ROI* nroi = [[ROI alloc] initWithType:tMesure :roi.pixelSpacingX :roi.pixelSpacingY :roi.imageOrigin];
                            [nroi addPoint:[[ps objectAtIndex:0] nsPoint]];
                            [nroi addPoint:[[ps objectAtIndex:1] nsPoint]];
                            [[_viewerController imageView] roiSet:nroi];
                            [[[_viewerController roiList] objectAtIndex:[[_viewerController imageView] curImage]] addObject:nroi];
                            [[NSNotificationCenter defaultCenter] postNotificationName:OsirixROIChangeNotification object:nroi userInfo:NULL];
                        }];
                }];
                
                NSTimeInterval z = [NSDate timeIntervalSinceReferenceDate];
                while ([NSDate timeIntervalSinceReferenceDate] < z+1) {
                    if ([thread isExecuting])
                        [NSThread sleepForTimeInterval:0.01];
                    else break;
                }
                
                if ([thread isExecuting])
                    [thread startModalForWindow:nil];
            }
        }
	}
	
	if (roi == _horizontalAxis) {
		_horizontalAxis = NULL;
		[_stepAxes setDone:NO];
		[_steps setCurrentStep:_stepAxes];
		[self updateLegInequality];
	}
	
	
	
	......
	
}

